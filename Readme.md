# Eisvil Test
![Unity](https://img.shields.io/badge/unity-%23000000.svg?style=for-the-badge&logo=unity&logoColor=white)
![Rider](https://img.shields.io/badge/Rider-000000.svg?style=for-the-badge&logo=Rider&logoColor=white&color=black&labelColor=crimson)
![C#](https://img.shields.io/badge/c%23-%23239120.svg?style=for-the-badge&logo=c-sharp&logoColor=white)
![Android](https://img.shields.io/badge/Android-3DDC84?style=for-the-badge&logo=android&logoColor=white)

![GitHub last commit](https://img.shields.io/github/last-commit/Tallaks/ArcheroTestEisvil)
## Table Of Contents
<details>
<summary>Table of contents</summary>

 - [Description](#description)
   - [Necessary points](#necessary-points)
   - [Additional functionality](#additional-functionality)
 - [Implementation](#implementation)
   - [Overview](#overview)
     - [Entry point](#entry-point)
   - [Features](#features)
     - [Enemy behaviour tree](#enemy-behaviour-tree)
   - [Unity](#unity) 
     - [Gameplay scenes](#gameplay-scenes)
     - [Physics](#physics)
     - [Prafabs and ScriptableObjects](#prafabs-and-scriptableobjects)
     - [Async and coroutines](#async-and-coroutines)
   - [Code](#code)
     - [Dependency injection](#dependency-injection)
     - [Async and coroutines](#async-and-coroutines-1)
     - [Factories and pools](#factories-and-pools)
   - [3rd party](#3rd-party)
</details>

## Description
**Задача:** реализовать базовый геймплей игры в стиле Archero.

**Технологии:** Unity3D (версия 2021.3.15.F1), C#.

### Necessary points
- [x] игровое поле заранее заданных размеров, вид сверху;
- [x] наличие 2х типов поведения противников;
- [x] наличие непроходимых по земле и непростреливаемых препятствий;
- [x] возможность управлять героем с помощью джойстика (движение);
- [x] эффекты попадания снарядов / смерти (формально);
- [x] герой должен получать монетки за убийство врагов;
- [x] камера на любых соотношениях сторон всегда охватывает всё игровое поле.

### Additional Functionality
- [ ] несколько типов оружия игрока;
- [x] умные противники: каждое перемещение ставит или приближает моба к прямой видимости игроком;
- [x] меню/окно паузы (базовый функционал UI/окон);
- [x] дополнительные типы поведения противников.

## Implementation
### Overview
Общими словами взаимодействие между объектами в игре можно описать следующим образом:
1. При загрузке сцены при в рамках фреймворка Zenject инициализирются все необходимые объекты, подгружаются необходимые ассеты и префабы и компоненты через внедрение зависимостей. 
2. Объекты взаимодействуют друг с другом, используя проинициализированные сервисы
3. При перезагрузке сцены все объекты уничтожаются, а сервисы переинициализируются.

#### Entry point
Точкой входа в приложения является сцена Bootstrap. При её запуске инициализируются базовые сервисы вроде асинхронного подгрузчика сцен, инпут-сервиса.
После биндинга всех зависимостей подгружается "шторка" загрузки, которая через Addressables инстанцируется в отдельном сервисе.
Загружается сцена Gameplay.

### Features
В этом разделе я опишу реализацию некоторых "интересных" моментов, которые я реализовал в рамках задания.
#### Enemy behaviour tree
Я не делал до этого древо поведений, так что решил попробовать, и использовал для этого структуру и метод работы [отсюда](https://www.gamedeveloper.com/programming/behavior-trees-for-ai-how-they-work)
В рамках данной реализации я реализовал 2 типа поведения противников:

**Лучник**

![Archero_media/Archer_BehaviourTree.png](Archero_media/Archer_BehaviourTree.png)

Вкратце он делает следующее:
1. Ждет, если игрок в зоне видимости
2. Идет к игроку, если он вне зоны видимости
3. После приближения к игроку или завершения времени ожидания останавливается и начинает целиться в игрока (появляется красная линия прицеливания)
4. После времени прицеливания стреляет в игрока и возвращается к пункту 1

**Летающий монстр**

![Archero_media/Flyer_BehaviourTree.png](Archero_media/Flyer_BehaviourTree.png)

Вкратце он делает следующее:
1. Ждет определенное время
2. Совершает быстрый рывок в сторону игрока. При этом, когда рывок уже начался, он не может изменить направление

Оба противника также наносят игроку урон при столкновении. Летаюший монстр ещё и может сдвинуть игрока с места.

#### Player attack system
Текущая версия проекта содержит только 1 тип оружия - стрелы. Тем не менее, я реализовал систему, которая позволяет легко добавлять
разные виды оружия, разные эффекты попадания, а также разные вариации имеющихся оружий. Всё это в рамках проекта должно
быть легко расширяемо и настраиваемо через ScriptableObject-конфиги.

### Unity
#### Gameplay scenes
В рамках задания я реализовал один игровой уровень, но в целом архитектура позволяет легко добавлять новые уровни при помощи:
- Темплейта сцены Level_Tempalte, содержащего в себе базовые игровое пространство без препятствий
- Addressable-сцен и отдельного сервиса для их подгрузки. Данная реализация позволяет не засорять лишний раз билд-индекс, а также простор для возможной реализации выбора уровня в зависимости от заданных параметров
- Отдельной сцены Gameplay, внутри которой хранятся общие и неизменяемые объекты, такие как камера, глобальные сервисы, UI и т.д.

#### Prafabs and ScriptableObjects
По возможности я старался избегать использование подгрузки из ресурсов, так что часть префабов подгражаются через Addressables, а часть - через ScriptableObject-конфиги,
ссылки на которые присутствуют на сценах. В частности, таким образом реализован спавн героя и противников - на сцене уровня присуствуют
точки спавна с ссылками на конфиги, а внутри конфигов хранятся префабы для инстанцирования.

В Adressables я использовал префабы для проджектайлов, эффект попадания снаряда, а также UI-префаб для загрузочного экрана в самом начале игры.
В данной реализации, в условиях ограниченного времени и отсутствия уточнений по поводу реализации контент-менеджмента, я
не стал реализовывать продуманную систему, а просто загрузил все требуемые префабы на этапе реализации. Впрочем, доработать
контент-менеджмент в данной реализации не составит труда, так как вся логика загрузки префабов и их инстанцирования вынесена в отдельные сервисы.

#### Physics
В условиях ограниченного времени реализация физических взаимодействий неидеальна. В частности, для корректного взаимодействия
объектов между собой потребовалось хранить много слоев физики. В целом, можно попробовать убрать слой HitBox, и использовать
attachedRigidbody для определения попадания в персонажа, но это я буду уже пробовать после отправки результата. Кроме этого ещё
можно убрать слой Border - его идея в том, чтобы ограничить перемещение персонажа за пределы игрового поля, даже с учетом
игнора препятствий (например, в случае летающего персонажа).

### Code
#### Dependency injection
Как уже было сказано, в качестве фреймворка для DI я использовал Zenject. Все сервисы, которые необходимы для работы приложения, инициализируются в соответствующих контексту контейнерах.
Там же, в инсталлерах, происходит инициализация и диспоуз сервисов и инстанс персонажей. Я старался избегать
инжекции каким либо образом кроме конструктора, но в некоторых местах пришлось использовать атрибут `[Inject]` 
для инжекции зависимостей в дочерние инсталлеры. В целом, внедрение зависимостей происходит либо в конструкторах, либо в методах `Initialize`

#### Async and coroutines
Асинхронность я старался использовать через UniTask, но в некоторых местах удобнее было использовать корутины. В частности, для реализации движения игрока по инпуту, с привязкой к фреймрейту.

#### Factories and pools
Для инстанцирования персонажей я использовал фабрики, внутри которой с учетом информации из привязанного к спавну конфига
инициализируются отдельные числовые характеристики вроде здоровья.

Для инстанцирования снарядов и эффектов я использовал пулы. Использовал я для этой цели реализацию пула из API Unity.

### 3rd party
Ниже представлены ссылки на все инструменты и ассеты, что я использовал в рамках реализации задания:
- [Zenject](https://github.com/modesttree/Zenject) - фреймворк для DI
- [UniTask](https://github.com/Cysharp/UniTask) - фреймворк для асинхронности без аллокаций
- [SRDebugger](https://assetstore.unity.com/packages/tools/gui/srdebugger-console-tools-on-device-27688) - удобный инструмент для отладки внутри устройства
- [Simple Touch Controller](https://assetstore.unity.com/packages/tools/input-management/simple-touch-controller-74107) - для спрайтов джойстика
- [Hit Impact Effects FREE](https://assetstore.unity.com/packages/vfx/particles/hit-impact-effects-free-218385) - эффекты попадания снарядов

